<?php

namespace OpenActu\UrlBundle\Repository;

use Doctrine\ORM\Query\ResultSetMapping;
use OpenActu\UrlBundle\Model\UrlManager;
use OpenActu\UrlBundle\Entity\UrlAnalyzer;
/**
 * UrlAnalyzerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UrlAnalyzerRepository extends \Doctrine\ORM\EntityRepository
{
	
	private function getCalculatedIds($qb)
	{
		$qb
		  ->select('max(a.id) id, a.requestUriCalculated')
		 
		  ->groupBy('a.requestUriCalculated')
		  ->orderBy('a.createdAt');			
	}
	
	private function getCalculatedCount($qb)
	{
		$qb
		  ->select('count(a)')
		  ->groupBy('a.requestUriCalculated');	
		$tab = $qb->getQuery()->getScalarResult();
		print_r($tab);die;
	}
	/**
	 * Obtain the data analyzis
	 *
	 * @param string $class Classname
	 * @param integer $offset Offset
	 * @param integer $limit Limit
	 */
	public function getQueryByAggregation($class,$page,$limit)
	{
		$output = array('items' => array(), 'count' => 0);

		if(get_parent_class($class) === UrlAnalyzer::class)
		{
			
			/**
			 * first step - we found the last id 
			 */
			$table_name = $this->_em->getClassMetadata($class)->getTableName();

			// items			
			$rsm = new ResultSetMapping();
			$sql = '
			SELECT sql_calc_found_rows max(a.id) id,b.uri_calculated
			FROM `'.$table_name.'` a 
			INNER JOIN url_core_analyzer b ON a.core_id = b.id
			GROUP BY b.uri_calculated
			ORDER BY a.created_at DESC
			LIMIT '.(($page-1)*$limit).','.$limit;
			$qb = $this->_em->createNativeQuery($sql,$rsm);
			$rsm->addScalarResult('id','id');
			$rsm->addScalarResult('uri_calculated','requestUriCalculated');
			$items = $qb->getScalarResult();
			
			// count
			$rsm = new ResultSetMapping();
			$sql = 'SELECT FOUND_ROWS() cpt';
			$qb = $this->_em->createNativeQuery($sql,$rsm);
			$rsm->addScalarResult('cpt','cpt');
			$count = $qb->getSingleScalarResult();
			
			$tmp = array();
			$uris= array();

			if(count($items) === 0)
			{
				return $output;
			}

			foreach($items as $item)
			{
				$tmp[]	= $item['id'];
				$uris[]	= $item['requestUriCalculated'];			
			}			

			// get items	
			$qb = $this->createQueryBuilder('a');
			$qb
			  ->select('a')
			  ->where($qb->expr()->in('a.id',$tmp));
			
			$output['items'] = $qb->getQuery()->getResult();
			$output['count'] = $count;
			
			/**
			 * lock update from oldiest version
			 *
			 */
			if(count($items) > 0) 
			{
				$conn = $this->_em->getConnection();

				foreach($items as $item)
				{					
					
					
					$sql = 'UPDATE `'.$table_name.'` a,url_core_analyzer b SET a.accept_update=0 WHERE a.core_id = b.id and b.uri_calculated = :requestUriCalculated AND a.id <> :id';
					$conn->executeUpdate($sql,array(
						':requestUriCalculated' => $item['requestUriCalculated'],
						':id' => $item['id'])
					);

				}
			}
			
			/**
			 * add statistics data
			 *
			 */
			if(count($output['items']) > 0)
			{
				foreach($output['items'] as $position => $item)
				{
					$sql ='
					SELECT 
					  avg(b.header_size) header_size,
				          b.http_code,
					  max(b.updated_at) updatedAt,
					  avg(b.total_time) totalTime,
					  avg(b.namelookup_time) namelookupTime, 
					  avg(b.connect_time) connectTime,
					  avg(b.pretransfer_time) pretransferTime,
					  avg(b.size_download) sizeDownload,
					  avg(b.speed_download) speedDownload,
					  avg(b.download_content_length) downloadContentLength,
					  avg(b.starttransfer_time) starttransferTime,
					  count(b.response_url) count
					FROM `'.$table_name.'` b, url_core_analyzer z 
					WHERE 
					  z.uri_calculated = :requestUriCalculated AND
					  z.id = b.core_id
					GROUP BY 
					  z.uri_calculated, 
					  b.http_code 
					ORDER BY 
	   				  b.http_code';
					
					$rsm = new ResultSetMapping();
					$qb = $this->_em->createNativeQuery($sql,$rsm);
					$qb->setParameter('requestUriCalculated', $item->getRequestUriCalculated());
					$rsm->addScalarResult('http_code', 'httpCode');		
					$rsm->addScalarResult('count', 'count');		
					$rsm->addScalarResult('sizeDownload', 'mediumSizeDownload');		
					$rsm->addScalarResult('downloadContentLength', 'mediumDownloadContentLength');		
					$rsm->addScalarResult('totalTime', 'mediumTotalTime');
					$statistics = $qb->getScalarResult();
					
					$item->setStatistics($statistics);
				}
			}
			return $output;
		}
		else
		{
			throw new \Exception('the current class '.$class.' is not supported');
		}
	}

        /**
  	 * Obtain the URL list who must be purged
         *
 	 */
	public function getEntitiesToBePurged($delay,$unit)
	{
		switch($unit)
		{
			case UrlManager::PURGE_UNIT_SECOND:
				$str_interval='PT'.$delay.'S';
				break;
			case UrlManager::PURGE_UNIT_MINUTE:
				$str_interval='PT'.$delay.'M';
				break;
			case UrlManager::PURGE_UNIT_DAY:
				$str_interval='P'.$delay.'D';
				break;
			case UrlManager::PURGE_UNIT_HOUR:
				$str_interval='PT'.$delay.'H';
				break;
			case UrlManager::PURGE_UNIT_MONTH:
				$str_interval='P'.$delay.'M';
				break;
		}
		
		$date	= date_sub(new \DateTime(),new \DateInterval($str_interval));

		$qb = $this
			->createQueryBuilder('a')
			->where('a.createdAt <= :date')
			->andWhere('a.acceptPurgeResponse = :acceptPurgeResponse')
			->andWhere('a.response IS NOT NULL')
			->setParameter('date',$date)
			->setParameter('acceptPurgeResponse',true);
		return $qb->getQuery()->getResult();
	}	
}
