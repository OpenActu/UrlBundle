<?php

namespace OpenActu\UrlBundle\Repository;

use OpenActu\UrlBundle\Model\UrlManager;
/**
 * UrlAnalyzerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UrlAnalyzerRepository extends \Doctrine\ORM\EntityRepository
{

	
	/**
	 * Obtain the data analysis by request uri field
	 *
	 * @param string $url URL string
	 * @return array
	 */
	public function getDatasByRequestUri($url)
	{
		$qb = $this->createQueryBuilder('a');
		$this->getAggregationSelect($qb);
		$this->getAggregationByRequestUri($qb,$url);
		return $qb->getQuery()->getScalarResult();
	}

        /**
  	 * Obtain the URL list who must be purged
         *
 	 */
	public function getEntitiesToBePurged($delay,$unit)
	{
		switch($unit)
		{
			case UrlManager::PURGE_UNIT_SECOND:
				$str_interval='PT'.$delay.'S';
				break;
			case UrlManager::PURGE_UNIT_MINUTE:
				$str_interval='PT'.$delay.'M';
				break;
			case UrlManager::PURGE_UNIT_DAY:
				$str_interval='P'.$delay.'D';
				break;
			case UrlManager::PURGE_UNIT_HOUR:
				$str_interval='PT'.$delay.'H';
				break;
			case UrlManager::PURGE_UNIT_MONTH:
				$str_interval='P'.$delay.'M';
				break;
		}
		
		$date	= date_sub(new \DateTime(),new \DateInterval($str_interval));

		$qb = $this
			->createQueryBuilder('a')
			->where('a.createdAt <= :date')
			->andWhere('a.acceptPurgeResponse = :acceptPurgeResponse')
			->andWhere('a.response IS NOT NULL')
			->setParameter('date',$date)
			->setParameter('acceptPurgeResponse',true);
		return $qb->getQuery()->getResult();
	}

	/**
	 * Obtain the data analysis by request uri without query nor fragment field
	 *
	 * @param string $url URL string
	 * @return array
	 */
	public function getDatasByRequestUriWithoutQueryNorFragment($url)
	{
		$qb = $this->createQueryBuilder('a');
		$this->getAggregationSelect($qb);
		$this->getAggregationByRequestUriWithoutQueryNorFragment($qb,$url);
		return $qb->getQuery()->getScalarResult();
	}	

	private function getAggregationByRequestUri($qb,$url)
	{
		$qb->groupBy('a.requestUri,a.httpCode');
		$qb->where('a.requestUri = :url')->setParameter('url',$url);	
	}

	private function getAggregationByRequestUriWithoutQueryNorFragment($qb,$url)
	{
		$qb->groupBy('a.requestUriWithoutQueryAndFragment,a.httpCode');
		$qb->where('a.requestUriWithoutQueryAndFragment = :url')->setParameter('url',$url);	
	}
	
	private function getAggregationSelect($qb)
	{
		$qb
			->select('
				a.requestScheme,
				a.requestHost,
				a.requestSubdomain,
				a.requestDomain,
				a.requestTopLevelDomain,
				a.requestFolder,
				a.requestFilename,
				a.requestFilenameExtension,
				a.requestPath,
				a.requestQuery,
				a.requestFragment,
				a.responseUrl,
				a.contentType,
				avg(a.headerSize) headerSize,
				a.requestSize,
				a.isDir,
				a.permissions,
				a.filetime,
				a.sslVerifyResult,

				a.httpCode,
				avg(a.totalTime) totalTime,
				avg(a.namelookupTime) namelookupTime, 
				avg(a.connectTime) connectTime,
				avg(a.pretransferTime) pretransferTime,
				avg(a.sizeDownload) sizeDownload,
				avg(a.speedDownload) speedDownload,
				avg(a.downloadContentLength) downloadContentLength,
				avg(a.starttransferTime) starttransferTime,
				count(a.responseUrl) calls'
			);
	}
	
}
