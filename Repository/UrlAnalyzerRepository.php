<?php

namespace OpenActu\UrlBundle\Repository;

use Doctrine\ORM\Query\ResultSetMapping;
use OpenActu\UrlBundle\Model\UrlManager;
use OpenActu\UrlBundle\Entity\UrlAnalyzer;
/**
 * UrlAnalyzerRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class UrlAnalyzerRepository extends \Doctrine\ORM\EntityRepository
{

	
	/**
	 * Obtain the data analysis by request uri field
	 *
	 * @param string $url URL string
	 * @return array
	 */
	public function getEntitiesByAggregatedRequestUri($class, $segment='request_uri', $offset=0,$limit=10)
	{
		if($segment !== 'request_uri' && $segment !== 'request_uri_without_query_nor_fragment')
			throw new \Exception('unknown segment ("'.$segment.'" given)');

		$sql = 'SELECT 
				max(b.id) id,
				b.request_uri,
				b.request_uri_without_query_nor_fragment,
				avg(b.header_size) header_size,
				b.http_code,
				max(b.updated_at) updatedAt,
				avg(b.total_time) totalTime,
				avg(b.namelookup_time) namelookupTime, 
				avg(b.connect_time) connectTime,
				avg(b.pretransfer_time) pretransferTime,
				avg(b.size_download) sizeDownload,
				avg(b.speed_download) speedDownload,
				avg(b.download_content_length) downloadContentLength,
				avg(b.starttransfer_time) starttransferTime,
				count(b.response_url) count
			FROM(
				SELECT 
					a.request_uri,
					a.request_uri_without_query_nor_fragment
				FROM 
					my_url a
				GROUP BY 
					a.'.$segment.'
				ORDER BY 
					a.created_at DESC
				LIMIT '.$offset.','.$limit.'
			) a1 
			INNER JOIN 
				my_url b 
			ON 
				b.'.$segment.' = a1.'.$segment.'
			GROUP BY 
				b.'.$segment.', 
				b.http_code 
			ORDER BY 
				b.'.$segment.', 
				b.http_code';

		$rsm = new ResultSetMapping();
		$qb = $this->_em->createNativeQuery($sql,$rsm);
		$rsm->addScalarResult('id','id');
		$rsm->addScalarResult('http_code','httpCode');
		$rsm->addScalarResult('request_uri','request_uri');
		$rsm->addScalarResult('request_uri_without_query_nor_fragment', 'request_uri_without_query_nor_fragment');		
		$rsm->addScalarResult('count','count');		
		$rsm->addScalarResult('sizeDownload','mediumSizeDownload');		
		$rsm->addScalarResult('downloadContentLength','mediumDownloadContentLength');		
		$rsm->addScalarResult('totalTime','mediumTotalTime');
		$rsm->addScalarResult('updatedAt','lastUpdatedAt');		
		$result = $qb->getScalarResult();
		
		$output = array();

		foreach($result as $item)
		{
			$entity = new $class();
			
			if($entity instanceof UrlAnalyzer)
			{
				if($segment == 'request_uri')
				{
					$test = ($entity->getRequestUri() !== $item['request_uri']);
				}
				else
				{
					$test = ($entity->getRequestUriWithoutQueryNorFragment() !== $item['request_uri_without_query_nor_fragment']);
				}

				if(true === $test)
				{
					if($entity->getId())
					{
						$output[] = $entity;
					}
					$entity = $this->_em->getRepository($class)->find($item['id']);
				}
				$entity->addStatistic($item);			
			}

			if($entity->getId())
			{
				$output[] = $entity;
			}

		}
		return $output;
	}

        /**
  	 * Obtain the URL list who must be purged
         *
 	 */
	public function getEntitiesToBePurged($delay,$unit)
	{
		switch($unit)
		{
			case UrlManager::PURGE_UNIT_SECOND:
				$str_interval='PT'.$delay.'S';
				break;
			case UrlManager::PURGE_UNIT_MINUTE:
				$str_interval='PT'.$delay.'M';
				break;
			case UrlManager::PURGE_UNIT_DAY:
				$str_interval='P'.$delay.'D';
				break;
			case UrlManager::PURGE_UNIT_HOUR:
				$str_interval='PT'.$delay.'H';
				break;
			case UrlManager::PURGE_UNIT_MONTH:
				$str_interval='P'.$delay.'M';
				break;
		}
		
		$date	= date_sub(new \DateTime(),new \DateInterval($str_interval));

		$qb = $this
			->createQueryBuilder('a')
			->where('a.createdAt <= :date')
			->andWhere('a.acceptPurgeResponse = :acceptPurgeResponse')
			->andWhere('a.response IS NOT NULL')
			->setParameter('date',$date)
			->setParameter('acceptPurgeResponse',true);
		return $qb->getQuery()->getResult();
	}	
}
